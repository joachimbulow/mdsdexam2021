/*
 * generated by Xtext 2.26.0
 */
package org.xtext.example.mydsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.mydsl.exTwentyOne.Program
import org.xtext.example.mydsl.exTwentyOne.Declaration
import org.xtext.example.mydsl.exTwentyOne.Function
import java.util.List
import java.util.ArrayList
import java.util.stream.Collectors
import org.xtext.example.mydsl.exTwentyOne.Expression
import org.xtext.example.mydsl.exTwentyOne.Plus
import org.xtext.example.mydsl.exTwentyOne.Minus
import org.xtext.example.mydsl.exTwentyOne.NewInput
import org.xtext.example.mydsl.exTwentyOne.LogicExp
import org.xtext.example.mydsl.exTwentyOne.DataAccess
import org.xtext.example.mydsl.exTwentyOne.IfThenElse
import org.xtext.example.mydsl.exTwentyOne.LetBinding
import org.xtext.example.mydsl.exTwentyOne.Node
import org.xtext.example.mydsl.exTwentyOne.Stream
import org.xtext.example.mydsl.exTwentyOne.Element
import org.xtext.example.mydsl.exTwentyOne.InputOrNode
import org.xtext.example.mydsl.exTwentyOne.Input
import java.util.HashMap
import java.util.Map
import org.xtext.example.mydsl.exTwentyOne.NodeOrFunction

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class ExTwentyOneGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val program = resource.allContents.filter(Program).next
		fsa.generateFile(
            "x21/" + program.name + ".java",
            program.compile);
		
	}
	
	def static compile(Program program) {
		'''
			package «program.name»;
			...
			public class «program.name.toUpper»Main extends GenericMainX21 {
			// Code for function add1
			«FOR function : filterDeclarations(program.declarations, typeof(Function))»
				«compileFunction(function as Function)»
			«ENDFOR»
			
			// Code for node add1node
			«FOR node : filterDeclarations(program.declarations, typeof(Node))»
				«compileNode(node as Node)»
			«ENDFOR»
			
			...
			«FOR outputNode : getOutputNodes(program.declarations)»
				«outputNode.output.compileOutputNode»
			«ENDFOR»
			
			«compileNodeInitialization(program.declarations)»
			
			«compileNodeNetwork(program.declarations)»
			
			}
		'''
	}
	
	def static compileFunction(Function function) {
		'''
		private Object fun_«function.name»(Object arg) {
			return funimpl_«function.name»((Integer)arg);
		}
		private Object funimpl_«function.name»(Integer _«function.lambda.name»){ return («function.lambda.lambdaExp.compileExpression»); }
		'''	
	}
	
	def static compileNode(Node node) {
		var functionCompilation = "";
		if (node.lambda !== null) {
			functionCompilation = '''
			«node.lambda.lambdaExp.compileExpression»
			'''
		}
		else {
			functionCompilation= '''
			fun_«node.function.name»(input)
			'''
		}
		'''
		private ComputeNode <Object,Object> node_«node.name» = new AbstractComputeNode<Object,Object>() {
			protected Object function(Object input) {
			return «functionCompilation»;
				}
		};
		'''	
	}
	
	def static compileOutputNode(String nodeName) {
		'''
		private OutputNode<Object> node_«nodeName» = new OutputNode<Object>();
					public List<Object> get«nodeName.toFirstUpper»() { return node_nodeName.getData(); }
		'''
	}
	
	def static compileNodeInitialization(List<Declaration> declarations){
		var nodesAndInputs = getNodesForInitialization(declarations);
		var result = '''
		// Initialization of specific nodes
		protected void initializeNodes() {
			«FOR nodeOrInput : nodesAndInputs»
				super.addNode(«nodeOrInput.compileInputOrNode»);
			«ENDFOR »
		}
		'''
	}
	
	def static compileNodeNetwork(List<Declaration> declarations) {
		var relationMap = getAllNetworkNodes(declarations);
		'''
		protected void initializeNetwork() {
			«FOR relationMapKey : relationMap.keySet»
				«relationMapKey».addOutputNode(node_«relationMap.get(relationMapKey)»);
			«ENDFOR »
		}
		'''
	}
	
	def static compileInputOrNode(InputOrNode inputOrNode){
    	switch inputOrNode {
    		Input: inputOrNode.name
    		Node: inputOrNode.name
    	}
    }
    
    def static compileElement(Element element){
    	if (element.getNode !== null) {
    		return element.getNode.compileNodeOrFunction
    	}
    	if (element.output !== null) {
    		return element.output;
    	}
    	if(element.element !== null) {
    		return element.element
    	}
    	return "something went wrong in compileElement";
    }
    
    def static compileNodeOrFunction(NodeOrFunction nodeOrFunction){
    	switch (nodeOrFunction){
    		Node: nodeOrFunction.name,
    		Function: nodeOrFunction.name
    	}
    }
	
	def static dispatch compileExpression(Plus exp) {
		"Plus!"
	}
	
	def static dispatch compileExpression(Minus exp) {
		"Minus!"
	}
	
	def static dispatch compileExpression(LetBinding exp) {
		"LetBinding!"
	}
	
	def static dispatch compileExpression(IfThenElse exp) {
		"IfThenElse!"
	}
	
	def static dispatch compileExpression(LogicExp exp) {
		"LogicExp!"
	}
	
	def static dispatch compileExpression(DataAccess exp) {
		"DataAccess!"
	}
	
	def static dispatch compileExpression(NewInput exp) {
		"NewInput!"	
	}
	
	def static dispatch compileExpression(Expression exp) {
		"Expression!"
	}
	
	def static toUpper(String it) {
        toUpperCase
    }
   
    
    def static filterDeclarations(List<Declaration> declarations, Class<?> type){
    	return declarations.stream.filter(declaration | type.isInstance(declaration)).collect(Collectors.toList());
    }
    
    def static getOutputNodes(List<Declaration> declarations) {
    	var streams = filterDeclarations(declarations, typeof(Stream));
    	var outputNodes = new ArrayList<Element>();
    	for (stream : streams) {
    		outputNodes.addAll((stream as Stream).elements.filter(e | e.output !== null));
    	}
    	return outputNodes;
    }
    
    def static getNodesForInitialization(List<Declaration> declarations) {
    	var inputs = filterDeclarations(declarations, typeof(Input));
    	var nodes = filterDeclarations(declarations, typeof(Node));
    	var nodesAndInputs = new ArrayList<InputOrNode>();
    	for (input : inputs) {
    		nodesAndInputs.add(input as Input);
    	}
    	for (node : nodes) {
    		nodesAndInputs.add(node as Node);
    	}
    	return nodesAndInputs;
    }
    
    def static getAllNetworkNodes(List<Declaration> declarations) {
    	var streams = filterDeclarations(declarations, typeof(Stream));
    	var relationMap = new HashMap<String, String>();
    	for (stream: streams) {
    		for (inputOrNode : (stream as Stream).inputsOrNodes){
    			for (element : (stream as Stream).elements){
    				relationMap.put(inputOrNode.compileInputOrNode, element.compileElement);
    			}
    		}
    	}
    	return relationMap;
    }
    
    
    
}
